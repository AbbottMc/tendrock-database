import { Block, Entity, ItemStack, World } from "@minecraft/server";
import { BlockDatabase, EntityDatabase, ItemStackDatabase, WorldDatabase } from "../impl";
import { GameObjectDatabase } from "../GameObjectDatabase";
import { DatabaseTypes } from "../DatabaseTypes";
import { ConstructorRegistry } from "../instance/ConstructorRegistry";
import { TendrockDynamicPropertyValue } from "../DynamicPropertySerializer";
export type Constructor<T> = new (...args: any[]) => T;
export type GameObjectType = Block | Entity | ItemStack | World | string;
export type DatabaseTypeBy<T> = T extends (string | Block) ? BlockDatabase : T extends Entity ? EntityDatabase : T extends ItemStack ? ItemStackDatabase : WorldDatabase;
export type DatabaseFactory<T extends Block | Entity | ItemStack | World | string> = {
    create(manager: DatabaseManager, gameObject: T, initialIdList?: [string, string][]): InstanceType<DatabaseFactory<T>>;
} & (new (...args: any[]) => any);
export type DatabaseTypeMap = {
    [DatabaseTypes.Entity]: EntityDatabase;
    [DatabaseTypes.Block]: BlockDatabase;
    [DatabaseTypes.Item]: ItemStackDatabase;
    [DatabaseTypes.World]: WorldDatabase;
};
export declare class DatabaseManager {
    static Instance: DatabaseManager;
    private readonly _databaseManagerMap;
    private readonly _eventCallbackMap;
    private readonly _changingEntityDatabaseBuffer;
    private _isInitialized;
    private _autoFlushTaskId;
    private _flushInterval;
    private _autoUpdateSourceEntity;
    private _autoFlush;
    private _blockDatabaseMap;
    private _itemDatabaseMap;
    private _entityDatabaseMap;
    private _worldDatabase;
    private _blockInitialIdListMap;
    private _worldInitialIdList;
    private _isFlushing;
    private _dirtyDatabaseList;
    private _dirtyDatabaseBuffer;
    protected constructor();
    private _triggerStartupEventWhenSystemStartup;
    private _loadAndParseWorldDynamicPropertiesGenerator;
    private _loadWorldDynamicProperties;
    private _loadWorldDynamicPropertiesWhenWorldLoad;
    private _addBlockDataId;
    private _addWorldDataId;
    protected _initWorldDataGenerator(): Generator<void, void, void>;
    protected _initBlockDataGenerator(): Generator<void, void, void>;
    private _initWorldBlockDataGenerator;
    private _doStartup;
    whenStartup(callback: (event: {
        constructorRegistry: ConstructorRegistry;
    }) => void): () => void;
    private _doReady;
    whenReady(callback: () => void): (() => void) | undefined;
    isReady(): boolean;
    _markDirty(runtimeId: string, dataBase: GameObjectDatabase<any>): void;
    setFlushInterval(interval: number, flush?: boolean): void;
    getFlushInterval(): number;
    setAutoFlush(value?: boolean): void;
    autoFlush(): boolean;
    setAutoUpdateSourceEntity(value?: boolean): void;
    autoUpdateSourceEntity(): boolean;
    private _flushDatabase;
    private _flushDataGenerator;
    private _flushDatabaseSync;
    private _flushSyncImpl;
    flushSync(): void;
    private _flushWhenShutdown;
    flush(): void;
    private _flushDataWhenPlayerLeave;
    private _clearFlushJobIfPresent;
    private _startAutoFlushTask;
    private _beginFlush;
    private _endFlush;
    private _prepare;
    createIfAbsent<T extends Block | Entity | ItemStack | World | string>(gameObject: T): DatabaseTypeBy<T>;
    get<T extends Block | Entity | ItemStack | World | string>(gameObject: T): DatabaseTypeBy<T> | undefined;
    remove<T extends Block | Entity | ItemStack | World | string>(gameObject: T, clearProperty?: boolean): void;
    getDatabaseList<T extends DatabaseTypes>(type: T): DatabaseTypeMap[T][];
    getWorldDatabase(): DatabaseTypeBy<World> | undefined;
    _addDatabase<T extends Block | Entity | ItemStack | World | string>(runtimeId: string, database: DatabaseTypeBy<T>): void;
    setData(gameObject: GameObjectType, identifier: string, value: TendrockDynamicPropertyValue): void;
    getData<T extends TendrockDynamicPropertyValue>(gameObject: GameObjectType, identifier: string): T;
    deleteData(gameObject: GameObjectType, identifier: string): boolean;
    buildDataInstanceIfPresent<T>(gameObject: GameObjectType, identifier: string, objectConstructor: Constructor<T>, options?: unknown): T | undefined;
    getDataBuiltInstance<T>(gameObject: GameObjectType, identifier: string): T | undefined;
    createDataInstanceIfAbsent<T>(gameObject: GameObjectType, identifier: string, objectConstructor: Constructor<T>, options?: unknown): T;
    getDirtyDatabaseList(): Array<GameObjectDatabase<any>>;
    getAllDirtyDatabaseList(): Array<GameObjectDatabase<any>>;
    _setChangingEntityDatabaseBuffer(runtimeId: string, locationId: string, entityDatabase: EntityDatabase): void;
    _getChangingEntityDatabaseBuffer(runtimeId: string, locationId: string): {
        entityDatabase: EntityDatabase | undefined;
        cleanBuffer: () => void;
    };
}
export declare const databaseManager: DatabaseManager;
